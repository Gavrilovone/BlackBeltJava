
package Collection.Interface_Map;

import java.util.HashMap;
import java.util.Map;

/**
 * В основе HashMap лежит массив.Элементами данного массива являются структуры LinkedList, данные структуры LinkedList и заполняются элементами,
 * которые мы добавляем в HashMap
 * При создании HashMap мы можем задать 2 параметра, которые очень влияют на производительность:
 * initial capacity - начальный размер массива(который назывется table)
 * Load factor - коэффициент того, насколько массив должен быть заполнен, после чего его размер будет увеличен вдвое(1)
 */
public class HashMap_in_dedails {
    public static void main(String[] args) {
        Map<Integer, String> map = new HashMap<>(16,0.75f); 
        /**
         * значения  initial capacity = 16 и Load factor = 0.75f   по умолчанию, это означает , что после того как наш массив table который состоит из 16
         * элементов заполнится на 75 процентов тоесть 12 ячеек, то его размер автоматически увеличится на 2 и станет 32 и все элементы HashMap будут рехешированы,
         * произойдет rehashin.Чем больше мы указываем начальный  initial capacity тем больше памяти он будет занимать, но тем меньше линкедлисты будут
         * образовываться внутри конкретной позиции массива и поиск будет происходить быстрее
         * 
         * поиск индекса в массиве происходит очень быстро за константное время O(1) и очень важно правильно реализовать наш hashcode иначе эта производитель
         * сводится на нет, например мы определим наш hashcode таким образом, что он всегда будет возвращать 3, соответственно индекс который вычесляется 
         * будет также всегда один и тот же и все элементы будут добавляться в одну ячейку нашего table и по сути это будет один большой linkedList, а как
         * известно у LinkedList поиск, добавление удаление элементов имеет O(n).в этом случае будет много коллизий и наш линкедлист будет очень длинным
         * Но после 8 java  если происходит такая ситуация и после превышения определенного порога длинны линкедлиста, HashMap перестает хранить элементы в
         * линкед листе и вместо связанных списков используются сбалансированные деревья(скорость поиска элемена в них O(log n))
         * 
         */
    }
}
